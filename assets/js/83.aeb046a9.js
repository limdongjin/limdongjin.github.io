(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{294:function(r,t,s){"use strict";s.r(t);var e=s(2),i=Object(e.a)({},function(){var r=this,t=r.$createElement,s=r._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[s("h1",{attrs:{id:"sp-2-sic의-구조-memory-reg-data-format"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sp-2-sic의-구조-memory-reg-data-format","aria-hidden":"true"}},[r._v("#")]),r._v(" [SP-2] SIC의 구조 (memory, reg, data format, ..)")]),r._v(" "),s("h2",{attrs:{id:"memory-sic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#memory-sic","aria-hidden":"true"}},[r._v("#")]),r._v(" Memory (SIC)")]),r._v(" "),s("ul",[s("li",[r._v("1 byte  : 8 bits")]),r._v(" "),s("li",[r._v("1 word : 3 bytes = 24 bits")]),r._v(" "),s("li",[r._v("All addresses are byte addresses")]),r._v(" "),s("li",[r._v("메모리는 총 2의 15승 byte")])]),r._v(" "),s("h2",{attrs:{id:"registers-sic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#registers-sic","aria-hidden":"true"}},[r._v("#")]),r._v(" Registers (SIC)")]),r._v(" "),s("p",[r._v("SIC 는 special purpose 레지스터를 5개 갖고 있으며, 각각 1 word (24 bits) 이다.")]),r._v(" "),s("p",[r._v("| Mnemonic | Number | 목적 |")]),r._v(" "),s("p",[r._v("| :--------: |:--------😐 :--------😐")]),r._v(" "),s("p",[r._v("| A | 0 | Accumulator : 산술 연산에 활용 |")]),r._v(" "),s("p",[r._v("| X | 1 | Index register : Addressing 할때 사용, 주소 저장 및 계산 |")]),r._v(" "),s("p",[r._v("| L | 2 | Linkage register: JSUB (Jump to Subroutine)할때 return address가 이 레지스터에 저장됨 |")]),r._v(" "),s("p",[r._v("| PC | 8 | Program Counter |")]),r._v(" "),s("p",[r._v("| SW | 9 | Status Word |")]),r._v(" "),s("h2",{attrs:{id:"data-format-sic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-format-sic","aria-hidden":"true"}},[r._v("#")]),r._v(" Data Format (SIC)")]),r._v(" "),s("p",[r._v("SIC 에서는 두가지의 데이터 포맷을 지원한다. floating-point number는 SIC에서는 지원하지 않고, SIC/XE 에서 지원합니다")]),r._v(" "),s("ul",[s("li",[r._v("Integer : 24 bits binary numbers")]),r._v(" "),s("li",[r._v("Character : 8 bits ASCII code")])]),r._v(" "),s("h2",{attrs:{id:"instruction-format-addressing-sic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#instruction-format-addressing-sic","aria-hidden":"true"}},[r._v("#")]),r._v(" Instruction Format , Addressing (SIC)")]),r._v(" "),s("ul",[s("li",[r._v("SIC 의 Instruction Format 길이는 1 word(24 bits) 입니다.")]),r._v(" "),s("li",[r._v("( SIC/XE 에서는 Instruction Format이 몇가지 추가됩니다 )")])]),r._v(" "),s("p",[s("img",{attrs:{src:"/images/sic-instruction-format.png",alt:""}})]),r._v(" "),s("ul",[s("li",[s("p",[r._v("Instruction Format")]),r._v(" "),s("ul",[s("li",[r._v("OP Code : 8 bits")]),r._v(" "),s("li",[r._v("X : 1 bit 를 차지한다. Addressing Mode 를 결정함.")]),r._v(" "),s("li",[r._v("Address : 15 bits")])])]),r._v(" "),s("li",[s("p",[r._v("Addressing")]),r._v(" "),s("ul",[s("li",[r._v("Direct Addressing: if X == 0, Target Address(TA) = Address")]),r._v(" "),s("li",[r._v("Index Addressing: if X == 1, TA = Address + [X]")]),r._v(" "),s("li",[r._v("(* [X]는 X 레지스터 안의 값을 나타냅니다)")])])])])])},[],!1,null,null,null);t.default=i.exports}}]);